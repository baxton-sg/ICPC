PART I

Revised  May 2013

Your name: 

It is to be understood that these questions are not to be posted on web sites, etc., or disclosed to others and that all assistance utilized is to be disclosed.  Although this should not have to be stated, from hard experience, candidates should please understand that compromising these suggestions does them no good as there are sufficient following actions to detect what candidates can do on their own.
	Initial here to show the above was read:_________________

Line in file	Contents
30	int  * someIDs, theFirst, *r;
110	someIDs =GetSomeIDs(); /* defined below */
111	theFirst = someIDs [0];
112	r= ReorderIDs(someIDs);
113-150	/* we want to use ‘theFirst’ and  ‘r’ here*/
	
499	/*-------- GetSomeIDs-----*/
500	int * GetSomeIDs()
501	{
502	   int  ids[8];
503-550	/* The ids are defined here */
551	  return  ids;
552	}

1. Is GetSomeIDs() a reasonable function?  
It’s wrongly implemented function. It returns a pointer to some location in the stack. This location might be (or even will be) overwritten after the function returns. In other words this function introduces undefined behavior.


2. Is there a different way to write line 500 which preserves the same effective prototype?  If so, what is it?
Depending on desired visibility it can be written as: 
static int* GetSomeIDs()


3. What will ‘theFirst’ contain after line 111 is executed?  Is this deterministic? Why?
With the provided implementation the content of “theFirst” is undefined.
Absolutely non-deterministic.
“someIDs” is pointing to the location in the stack which is released  after the function GetSomeIDs returns. Compiler can (and usually does) insert some instructions modifying the stack _before_ the “theFirst” is assigned. This leads to the situation when some un-defined value is read instead of the first item of the array. But in some cases it can really contain the value of the first item of the array, that’s why the issue can appear randomly in runtime.


4. What line(s) not given should be provided for compilation?
Declaration of the GetSomeIDs in the beginning or an “#include” directive to include declarations.


5. Is GetSomeIDs() good practice, and why?
Apart from the issues in the function implementation:
In general it’s ok to have an API function which fetches and returns some IDs (any other data). Usually the memory should be dynamically allocated due to the number of IDs can differ. Also it’s necessary to return the number of items in the array along with the array itself.
In case of dynamically allocated memory it’s necessary to have a counterpart function releasing the allocated array (FreeSomeIDs).
But I cannot say GetSomeIDs is a good practice, because of the issues with the function:
1)	Array should be declared as “static” or should be dynamically allocated. In this case the data will be preserved between the function calls:
static int ids[8];
2)	Magic number in the array declaration. It should be at least replaced by some named constant:
const int NUM_OF_IDS = 8;	// I only have 8 IDs… always and forever!!!
static int ids[NUM_OF_IDS];
3)	What if number of IDs is less (greater) than 8? There is no way to show this to the caller
4)	The function returns a fixed size array. This will require re-compilation for the library and for clients in case of any change
5)	In case the initialization of IDs fails there is no way to notify the caller about this
6)	No comments in the code explaining the logic
7)	The function is an API one and should be moved to a separate file. In other words API functions should be separated from the business logic
8)	



6. Might the code shown execute at all?    
Shortly the answer is: sometimes it might. But in general case the behavior is undefined.


7.  Correct the problems with GetSomeIDs(), and add some additional functionality to it, as follows.  A  single new version of the function should be provided.

a) Maintain the same "int *" return type which returns a pointer to fixed sized array of ints.

 b) IN ADDITION to its regular function return, provide to its calling functions a usable array of pointers to aliasID  structures.  The length of this array of pointers is returned by a call to GetNumberOfAliases(), which you may call only from within GetSomeIDs(). 

 c) Use the structure and the functions defined below:

    typedef struct {
        char* alias;   /* '\0'-terminated C string */
        int   specific_id;
    } aliasID;


    /* How many structures should be pointed to by the array 
     */
    int GetNumberOfAliases(void);

    /* Get a pointer to the next structure.  The structure itself
     * will be filled with data.
     * Caller is responsible for the cleanup of the returned structure
     *     and its content. The latter are allocated in 
     *     dynamic memory.
     */
    aliasID * GetNextAlias(void);

   Do NOT(!) use "C++" syntax or language constructs.  
This should be written in plain “C”.
   Use good programming practice, as much as these instructions allow.



8 .  Write a function which calls GetSomeIDs() as described in (7) above, prints out all data returned by it, and cleans up resources allocated in dynamic memory.
		
   For both (7), and (8), above, DO NOT use "C++" syntax or language contructs.  These should be written in plain “C”.
   Use good programming practice, as much as these instructions allow.


9. If you know SQL, please, as simply as possible, design a single table to hold orders made by customers.  You may assume details (including names) about customers are held in some other table.  Using the table that you designed for orders, and this other table, present a single query that gives the number of orders for every customer, one line per customer.  


For testing this I used Sybase DB server and isql utility:
create table orders (
     order_id integer identity, 
     customer_id integer,
     item_id integer,
     item_count integer,
     note varchar(100)
)

Sybase specific join:
select count(o.order_id), c.first_name, c.last_name from customers c, orders o where o.customer_id =* c.customer_id group by c.customer_id

And with using JOIN:

select count(o.order_id), c.first_name, c.last_name from customers c left join orders o on o.customer_id = c.customer_id group by c.customer_id



10. If you know Python, please answer the following: 
There's a problem with the  

following Python 2.x code, please fix it.

print reduce(lambda x, y: x+y, filter(lambda x: x%2, map(lambda x: x*x, xrange 

(10**6)))) = sum(x*x for x in xrange(1, 10**6, 2))

After the fix, what would be printed?  Explain the result.

print reduce(lambda x, y: x+y, 
                    filter(lambda x: x%2, map(lambda x: x*x, xrange(10**6))), 
                    sum((x*x for x in xrange(1, 10**6, 2))))

Run on my Python 2.4 returned: 333333333333000000
How it works:
sum - returns a single value – a sum of elements of a squares of integers from [1..1M) with step 2 (in the fixed version a generator of sequence)
filter – returns a sequence of odd numbers from squares of integers from [0..1M)
reduce – applies cumulatively the lambda function to elements of the sequence returned by “filter” and uses the value returned by “sum” as initial one.



A. What resources (references texts or URLs) did you use to help you answer these questions and what help did they provide?
I used no external resources. 


B. What help did others provide towards answering these questions?
I answered on my own. Nobody helped me.


PART II

Revised  Summer, 2012

Your name: 

It is to be understood that these questions are not to be posted on web sites, etc., or disclosed to others and that all assistance utilized is to be disclosed.  Although this should not have to be stated, from hard experience, candidates should please understand that compromising these suggestions does them no good as there are sufficient following actions to detect what candidates can do on their own.
	Initial here to show the above was read:_________________

1.	Write a “C” function that modifies each element of a user supplied array by applying a user-provided function to each element of an array of integers. The user-provided function can also accept parameters.  Please provide a typedef for the user-provided function.

Very generic implementation – can be used for different data types:

typedef int (*processor_t) (void*, void*);

// Note: I _do_not_ check parameters passed to this API function. This is a responsibility of a caller.
int for_each(void* array, size_t size, size_t item_size_bytes, processor_t processor, void* proc_param) {
    int result = 0; // 0 means no errors
    char* p = (char*)array;
    char* end = p + size * item_size_bytes;

    for (; p != end; p += item_size_bytes) {
        result = processor(p, proc_param);
        if (0 != result)
            break;
    }
    return result;
}

// very simple examples of user defined functions
int set_int(void* v, void* init_val) {
    *(int*)v = *(int*)init_val;
    return 0;
}

int set_char(void* v, void* init_val) {
    *(char*)v = *(char*)init_val;
    return 0;
}

// usage
int val = 0;
int vector[] = {1,2,3,4,5};
for_each(vector, sizeof(vector)/sizeof(int), sizeof(int), set_int, &val);



2.	Write a “C” function to convert an array to a doubly-linked list.




3.	What resources (references texts or URLs) did you use to help you answer these questions and what help did they provide?
Nothing	


4.	What help did others provide towards answering these questions?
No help from anyone

